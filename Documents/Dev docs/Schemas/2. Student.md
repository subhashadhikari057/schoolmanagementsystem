### üóÇÔ∏è Tables Overview:

|Table Name|Purpose|
|---|---|
|`students`|Core student record, linking user identity and academic placement|
|`parent_student_links`|Many-to-many links connecting parents with their children|
|`student_profiles`|Extended student metadata and customizable profile information|
|`exam_results`|**New:** per-student marks for class / assessment records|

---

## üìÑ Schema Definitions (PostgreSQL + SQL DDL)

---

### üßë‚Äçüéì `students`

```sql
CREATE TABLE student.students (
    id            UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id       UUID UNIQUE NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    class_id      UUID NOT NULL REFERENCES academics.classes(id),
    section_id    UUID NOT NULL REFERENCES academics.sections(id),
    roll_number   VARCHAR(20) NOT NULL,
    dob           DATE,
    gender        VARCHAR(10) CHECK (gender IN ('male', 'female', 'other')),
    additional_metadata JSONB DEFAULT '{}',

    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ,
    deleted_at TIMESTAMPTZ,

    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id),
    deleted_by UUID REFERENCES auth.users(id),

    CONSTRAINT unique_roll_per_class_section
        UNIQUE (class_id, section_id, roll_number)
);

-- Indexes for quick look-ups and auditing
CREATE INDEX idx_students_user_id     ON student.students(user_id);
CREATE INDEX idx_students_class_id    ON student.students(class_id);
CREATE INDEX idx_students_section_id  ON student.students(section_id);
CREATE INDEX idx_students_created_by  ON student.students(created_by);
CREATE INDEX idx_students_updated_by  ON student.students(updated_by);
CREATE INDEX idx_students_deleted_by  ON student.students(deleted_by);
```

---

### üë™ `parent_student_links`

```sql
CREATE TABLE student.parent_student_links (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    parent_id  UUID NOT NULL REFERENCES auth.users(id)     ON DELETE CASCADE,
    student_id UUID NOT NULL REFERENCES student.students(id) ON DELETE CASCADE,
    relationship VARCHAR(50),         -- e.g. 'father', 'mother', 'guardian'
    linked_at   TIMESTAMPTZ DEFAULT now(),

    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ,
    deleted_at TIMESTAMPTZ,

    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id),
    deleted_by UUID REFERENCES auth.users(id),

    CONSTRAINT unique_parent_student UNIQUE (parent_id, student_id)
);

CREATE INDEX idx_parent_student_links_parent_id  ON student.parent_student_links(parent_id);
CREATE INDEX idx_parent_student_links_student_id ON student.parent_student_links(student_id);
CREATE INDEX idx_parent_student_links_created_by ON student.parent_student_links(created_by);
CREATE INDEX idx_parent_student_links_updated_by ON student.parent_student_links(updated_by);
CREATE INDEX idx_parent_student_links_deleted_by ON student.parent_student_links(deleted_by);
```

---

### üìá `student_profiles`

```sql
CREATE TABLE student.student_profiles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    student_id UUID UNIQUE NOT NULL
        REFERENCES student.students(id) ON DELETE CASCADE,

    bio               TEXT,
    profile_photo_url TEXT,
    emergency_contact JSONB DEFAULT '{}'::jsonb, -- {name, phone, relation}
    interests         JSONB DEFAULT '{}'::jsonb,
    additional_data   JSONB DEFAULT '{}'::jsonb,

    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ,
    deleted_at TIMESTAMPTZ,

    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id),
    deleted_by UUID REFERENCES auth.users(id)
);

CREATE INDEX idx_student_profiles_student_id ON student.student_profiles(student_id);
CREATE INDEX idx_student_profiles_created_by ON student.student_profiles(created_by);
CREATE INDEX idx_student_profiles_updated_by ON student.student_profiles(updated_by);
CREATE INDEX idx_student_profiles_deleted_by ON student.student_profiles(deleted_by);
```

---

### üìù `exam_results` **(NEW ‚Äì aligns `marks_obtained` & `start_time`)**

```sql
CREATE TABLE student.exam_results (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    student_id UUID NOT NULL
        REFERENCES student.students(id) ON DELETE CASCADE,

    exam_id    UUID NOT NULL
        REFERENCES exam.exams(id) ON DELETE CASCADE,

    subject_id UUID NOT NULL
        REFERENCES academics.subjects(id) ON DELETE CASCADE,

    start_time TIMESTAMPTZ NOT NULL,  -- unified naming (was `start_at`)
    end_time   TIMESTAMPTZ,
    marks_obtained NUMERIC(5,2) NOT NULL, -- enforce NUMERIC type
    max_marks      NUMERIC(5,2) NOT NULL,
    grade          VARCHAR(10),

    remarks TEXT,

    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ,
    deleted_at TIMESTAMPTZ,

    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id),
    deleted_by UUID REFERENCES auth.users(id),

    CONSTRAINT unique_result_per_exam_subject_student
      UNIQUE (exam_id, subject_id, student_id)
);

CREATE INDEX idx_exam_results_student   ON student.exam_results(student_id);
CREATE INDEX idx_exam_results_exam      ON student.exam_results(exam_id);
CREATE INDEX idx_exam_results_subject   ON student.exam_results(subject_id);
CREATE INDEX idx_exam_results_starttime ON student.exam_results(start_time);
```

---

## üìå Indexing & Auditing Best Practices

- All FK columns have supporting indexes for JOIN speed.
    
- Soft-delete (`deleted_at`) everywhere enables reversible operations.
    
- New `exam_results` table **ensures**:
    
    - `marks_obtained` is strictly **`NUMERIC`** for accurate calculations.
        
    - Time fields consistently use **`start_time / end_time`** (never `start_at`).
        
- Composite uniqueness on `(exam_id, subject_id, student_id)` guards against duplicate result rows.
    

---