---

## 🔧 Guiding Principles

| Principle                                    | Description                                                                                  |
| -------------------------------------------- | -------------------------------------------------------------------------------------------- |
| **📦 Modularity by Contract**                | Every domain module operates as a self-contained boundary governed by interfaces.            |
| **🔐 Explicit Boundaries**                   | No direct imports between modules. Use DI (Dependency Injection) and public interfaces only. |
| **🧪 Testability & Isolation**               | Each module can be developed and tested independently without side effects.                  |
| **♻️ Composability**                         | Frontend follows Atomic Design principles; Backend follows Domain-Driven Design (DDD).       |
| **📚 Convention First, Configuration Later** | The structure should guide behavior. Tools enforce discipline, not dev habits.               |

---

## 🧠 Backend

```
📦 backend/
├── 📁 src/
│   ├── 📁 modules/                    # Domain-Driven Bounded Contexts (no cross-importing)
│   │   ├── 📁 auth/
│   │   ├── 📁 students/
│   │   │   ├── application/          # Business logic orchestration layer (Services, Use Cases)
│   │   │   ├── domain/               # Domain entities, aggregates, value objects, interfaces
│   │   │   ├── infrastructure/       # Data persistence adapters, API adapters
│   │   │   ├── dto/                  # Data Transfer Objects
│   │   │   └── student.module.ts     # Entry point: declares DI, exports, config
│   │   ├── 📁 teacher/
│   │   ├── 📁 attendance/
│   │   └── ...
│   │
│   ├── 📁 shared/                    # Truly reusable utilities or policies (non-domain specific)
│   │   ├── 📁 guards/
│   │   ├── 📁 middlewares/
│   │   ├── 📁 logger/
│   │   ├── 📁 config/
│   │
│   │   └── interfaces/
│   │
│   ├── 📁 infrastructure/           # Cross-cutting external concerns (DB, Email, FileUpload)
│   │   ├── 📁 database/
│   │   │   ├── prisma/
│   │   │   ├── mongoose/
│   │   ├── 📁 mailer/
│   │   └── ...
│   ├── 📁 common/                   # Global constants, types, decorators
│   └── main.ts                      # App bootstrap
│
├── 📁 test/
│   ├── unit/
│   └── integration/
├── .env
├── Dockerfile
└── tsconfig.json
```

### 🔑 Key Backend Principles

| Area                     | Principle                                                                                         |
| ------------------------ | ------------------------------------------------------------------------------------------------- |
| **Domain**               | Each feature has its own domain language and model — strictly encapsulated                        |
| **Application Layer**    | Use cases orchestrate flow between services, repositories, and domain logic                       |
| **Infrastructure**       | Adapters for databases, APIs, emails — never referenced directly by domain logic                  |
| **Dependency Injection** | Each module gets only what it needs. Use constructor injection + DI container                     |
| **Validation**           | Zod or Joi for schema validation — always in `dto/`, not in controller logic                      |
| **Security**             | RBAC and authentication are in `auth/` and wrapped as guards/middleware — never in business logic |

---

## 🌐 Frontend (React + TypeScript + Atomic + App Router)

```
📦 frontend/
├── 📁 src/
│   ├── 📁 app/                      # Pages and layouts (App Router or React Router)
│   │   ├── dashboard/              # Layout for authenticated users
│   │   │   ├── student/
│   │   │   ├── teacher/
│   │   │   ├── parent/
│   │   │   ├── admin/
│   │   └── auth/                   # Login, Register, Forgot
│
│   ├── 📁 components/              # Atomic Design System
│   │   ├── atoms/                 # Buttons, TextField, Tags
│   │   ├── molecules/             # InputWithLabel, AvatarWithMenu
│   │   ├── organisms/             # Full forms, navbars, layout components
│   │   └── layout/                # AppShells, PageGrids
│
│   ├── 📁 features/               # Feature modules (matches backend domain)
│   │   ├── attendance/
│   │   ├── complaints/
│   │   ├── timetable/
│   │   ├── announcements/
│
│   ├── 📁 hooks/                  # useAuth, useFetchWithToken, useFormLogic
│   ├── 📁 lib/                    # Axios config, classNames, utility helpers
│   ├── 📁 store/                  # Zustand or Redux slices, persisted logic
│   ├── 📁 constants/              # Roles, Permissions, Enums
│   ├── 📁 types/                  # Shared types/interfaces across app
│   └── 📁 styles/                 # Tailwind configs, global styles, theming
│
├── .env
├── tailwind.config.ts
├── tsconfig.json
└── next.config.js
```

### 🔑 Key Frontend Principles

| Principle                          | Implementation                                                              |
| ---------------------------------- | --------------------------------------------------------------------------- |
| **Atomic Design**                  | Prevents over-abstracting. Reuse is done at _composition_ level             |
| **Role-based UI**                  | Routes and layouts are role-scoped. `authContext` governs access at runtime |
| **Domain Separation**              | No feature logic bleeds into `components/` — UI and logic are separate      |
| **Global state only if necessary** | Store only cross-cutting state (e.g., auth, user role)                      |
| **Server-State from Source**       | Always use API fetch with cache (SWR/React Query), avoid local duplication  |

---

## 🧾 Naming Conventions (Universal)

| Item             | Rule                   | Example                           |
| ---------------- | ---------------------- | --------------------------------- |
| Folder names     | `kebab-case`           | `student-module`                  |
| Files            | `kebab-case`           | `student.service.ts`              |
| Classes          | `PascalCase`           | `StudentService`                  |
| Variables        | `camelCase`            | `studentId`, `attendanceCount`    |
| Constants        | `SCREAMING_SNAKE_CASE` | `MAX_ATTENDANCE_LIMIT`            |
| Types/Interfaces | `PascalCase`           | `StudentDTO`, `IAttendanceRecord` |

---

## 🎯 Code Enforcement Stack

| Tool            | Purpose                                       |
| --------------- | --------------------------------------------- |
| ESLint          | Airbnb + Prettier + TypeScript rules          |
| Prettier        | Automatic formatting                          |
| Husky           | Pre-commit hooks for lint/test                |
| Lint-staged     | Partial commit blocking if lint/test fails    |
| Commitlint      | Force semantic commits (`feat:`, `fix:`)      |
| tsconfig strict | Full strict mode, no `any` allowed            |
| dotenv-safe     | Enforces env var presence across environments |

---

## 🚫 Anti-Patterns to Eliminate

| Bad Practice                           | Better Alternative                             |
| -------------------------------------- | ---------------------------------------------- |
| Direct imports across modules          | Use shared interfaces/contracts                |
| Shared business logic in components    | Move to `features/` or backend                 |
| Large utils folder with random helpers | Keep utilities domain-aware                    |
| Logic in controllers                   | Thin controllers, fat services/use cases       |
| Central global state for everything    | Decentralized local state unless cross-cutting |

---

## 🧩 Key Enforcement Techniques

- **Code fencing** with project references or `module boundaries` (e.g., with Nx or turbo-pack)
- **Interface-only communication** between modules — never import raw services
- **Dependency Injection containers** (e.g., Inversify, NestJS DI) to decouple components
- **Shared DTOs/Types** must live in a `contracts/` folder or package, and must never contain logic
- **Feature flags** and `RoleGuard` must sit _outside_ core logic — injected as policy evaluators

---

## 🔄 Optional Enhancements

| Enhancement                                | Benefit                                                    |
| ------------------------------------------ | ---------------------------------------------------------- |
| **Nx Monorepo (for larger teams)**         | Strong module boundary enforcement, testing, CI splits     |
| **Shared NPM package for types/contracts** | Avoid tight coupling, allow versioning                     |
| **Storybook + Chromatic**                  | UI-driven development, perfect for reusable components     |
| **GraphQL/REST Hybrid**                    | Use REST for mutations, GraphQL for read efficiency        |
| **Role-driven layout shells**              | `RoleShell(student)` auto-loads navbars and allowed routes |

---

## ✅ Summary

This structure reflects a **professional, modular, and future-proof** system aligned with your goals:

- Single-school focus, but multi-role and multi-feature
- Strictly enforced **boundaries** between features
- Complete consistency from API to UI
- Ready for secure scaling and real-world team development

Would you like me to:

1. Create actual file stubs or `README.md` templates for each folder to guide onboarding?
2. Generate a visual architecture diagram showing all modules and their separation?
3. Extend this into a CI/CD and repo structure setup?

Let’s sharpen it further.
