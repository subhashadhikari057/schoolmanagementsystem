### 🗂️ Tables Overview:

| Table Name      | Purpose                                                       |
| --------------- | ------------------------------------------------------------- |
| `notices`       | Broadcast or targeted announcements to users or groups        |
| `complaints`    | User-submitted complaints with status and resolution tracking |
| `conversations` | Thread of messages among participants (1:1 or group)          |
| `messages`      | Individual messages belonging to conversations                |

---

## 📄 Schema Definitions (PostgreSQL + SQL DDL)

---

### 📢 `notices`

```sql
CREATE TABLE communication.notices (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    title        VARCHAR(255) NOT NULL,
    content      TEXT NOT NULL,
    published_at TIMESTAMPTZ,           -- nullable until published
    expires_at   TIMESTAMPTZ,           -- optional expiry

    author_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE SET NULL,

    is_active    BOOLEAN DEFAULT TRUE,
    is_broadcast BOOLEAN DEFAULT TRUE,  -- false = targeted

    metadata JSONB DEFAULT '{}',

    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ,
    deleted_at TIMESTAMPTZ,

    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id),
    deleted_by UUID REFERENCES auth.users(id)
);

CREATE INDEX idx_notices_published_active ON communication.notices(published_at, is_active);
CREATE INDEX idx_notices_author          ON communication.notices(author_id);
```

---

### 🆘 `complaints`

```sql
CREATE TYPE communication.complaint_status
       AS ENUM ('new','in_progress','resolved','closed','rejected');

CREATE TABLE communication.complaints (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    complainant_id   UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    against_user_id  UUID         REFERENCES auth.users(id) ON DELETE SET NULL,

    subject       VARCHAR(255) NOT NULL,
    description   TEXT        NOT NULL,

    status communication.complaint_status DEFAULT 'new',

    assigned_to      UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    resolution_notes TEXT,

    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ,
    closed_at  TIMESTAMPTZ,
    deleted_at TIMESTAMPTZ,

    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id),
    deleted_by UUID REFERENCES auth.users(id)
);

CREATE INDEX idx_complaints_complainant ON communication.complaints(complainant_id);
CREATE INDEX idx_complaints_status      ON communication.complaints(status);
CREATE INDEX idx_complaints_assigned_to ON communication.complaints(assigned_to);
```

---

### 💬 `conversations`

```sql
CREATE TABLE communication.conversations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    subject   VARCHAR(255),
    is_group  BOOLEAN DEFAULT FALSE,

    metadata JSONB DEFAULT '{}',

    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ,
    deleted_at TIMESTAMPTZ,

    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id),
    deleted_by UUID REFERENCES auth.users(id)
);
```

---

### 📨 `messages`

```sql
CREATE TABLE communication.messages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    conversation_id UUID NOT NULL REFERENCES communication.conversations(id) ON DELETE CASCADE,
    sender_id       UUID NOT NULL REFERENCES auth.users(id) ON DELETE SET NULL,

    content     TEXT    NOT NULL,
    attachments JSONB   DEFAULT '[]'::jsonb,

    is_read BOOLEAN DEFAULT FALSE,
    read_at TIMESTAMPTZ,

    sent_at TIMESTAMPTZ DEFAULT now(),

    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ,
    deleted_at TIMESTAMPTZ,

    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id),
    deleted_by UUID REFERENCES auth.users(id)
);

CREATE INDEX idx_messages_conversation ON communication.messages(conversation_id);
CREATE INDEX idx_messages_sender       ON communication.messages(sender_id);
CREATE INDEX idx_messages_sent_at      ON communication.messages(sent_at);
CREATE INDEX idx_messages_is_read      ON communication.messages(is_read);
```

> **Pagination Guard Recommendation**  
> Any service that fetches from `communication.messages` (for example, `GET /messages` or `GET /messages/conversations/:id`) **must** cap result-set size in SQL:
>
> ```sql
> LIMIT GREATEST(LEAST(:limit, 100), 10)   -- default 10, max 100
> OFFSET GREATEST(:offset, 0)
> ```
>
> The API layer should validate `limit`/`offset` to enforce these bounds and avoid full-table scans.

---

### 🔗 `conversation_participants`

```sql
CREATE TABLE communication.conversation_participants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    conversation_id UUID NOT NULL REFERENCES communication.conversations(id) ON DELETE CASCADE,
    user_id         UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,

    joined_at TIMESTAMPTZ DEFAULT now(),
    left_at   TIMESTAMPTZ,

    is_admin BOOLEAN DEFAULT FALSE,

    UNIQUE (conversation_id, user_id)
);

CREATE INDEX idx_conv_participants_conv_id ON communication.conversation_participants(conversation_id);
CREATE INDEX idx_conv_participants_user_id ON communication.conversation_participants(user_id);
```

---

## 📌 Design Notes & Rationale

- **Pagination Guard** protects high-volume endpoints (`messages`, `notices`) from accidental or malicious full-table reads.  
   Limits are enforced in both SQL (see snippet above) **and** in request validators.
- Notices rely on soft-publish controls (`published_at`, `expires_at`) plus flexible targeting flags.
- The complaints workflow uses a Postgres `ENUM` for clear status progression and indexing.
- Conversations separate thread metadata from participant entries for efficient joins and permission checks.
- All tables carry detailed **audit** fields (`created_by`, `updated_by`, `deleted_by`) and support soft deletion (`deleted_at`) for compliance and historical review.

---
