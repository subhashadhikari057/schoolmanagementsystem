### üóÇÔ∏è Tables Overview

|Table Name|Purpose|
|---|---|
|`attendance_records`|Daily attendance logs per student / class / section|
|`leave_requests`|Student / teacher leave applications with approval workflow|
|`absentee_flags`|Flags for prolonged absences or pattern anomalies|

---

## üìÑ Schema Definitions (PostgreSQL + SQL DDL)

---

### üìí `attendance_records`

```sql
-- Create ENUM for attendance status
CREATE TYPE attendance.attendance_status_enum AS ENUM ('present', 'absent', 'late', 'excused', 'unknown');

CREATE TABLE attendance.attendance_records (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    student_id UUID NOT NULL
        REFERENCES student.students(id) ON DELETE CASCADE,
    class_id   UUID NOT NULL
        REFERENCES academics.classes(id)  ON DELETE RESTRICT,
    section_id UUID NOT NULL
        REFERENCES academics.sections(id) ON DELETE RESTRICT,

    attendance_date DATE NOT NULL,

    status  attendance.attendance_status_enum NOT NULL DEFAULT 'unknown',
    remarks TEXT,

    additional_metadata JSONB DEFAULT '{}',

    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ,
    deleted_at TIMESTAMPTZ,

    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id),
    deleted_by UUID REFERENCES auth.users(id),

    -- One row per-student per-day
    CONSTRAINT unique_attendance_per_student_date
        UNIQUE (student_id, attendance_date)
);

-- Indexes for fast filters & joins
CREATE INDEX idx_attendance_records_student        ON attendance.attendance_records(student_id);
CREATE INDEX idx_attendance_records_class_section  ON attendance.attendance_records(class_id, section_id);
CREATE INDEX idx_attendance_records_date           ON attendance.attendance_records(attendance_date);
CREATE INDEX idx_attendance_records_status         ON attendance.attendance_records(status);
CREATE INDEX idx_attendance_records_created_by     ON attendance.attendance_records(created_by);
CREATE INDEX idx_attendance_records_updated_by     ON attendance.attendance_records(updated_by);
CREATE INDEX idx_attendance_records_deleted_by     ON attendance.attendance_records(deleted_by);
```

> **üîí Concurrency-safe upsert example**  
> Prevents accidental double-marking when two teachers mark the same student simultaneously:
> 
> ```sql
> INSERT INTO attendance.attendance_records
>     (student_id, class_id, section_id,
>      attendance_date, status, remarks, created_by)
> VALUES
>     (:student_id, :class_id, :section_id,
>      :attendance_date, :status, :remarks, :user_id)
> ON CONFLICT (student_id, attendance_date)
> DO UPDATE
>     SET status      = EXCLUDED.status,
>         remarks     = EXCLUDED.remarks,
>         updated_at  = NOW(),
>         updated_by  = :user_id;
> ```
> 
> Use **`DO NOTHING`** instead of `DO UPDATE` if you want the first mark to win.

---

### üìù `leave_requests`

```sql
-- Create ENUMs for leave management
CREATE TYPE attendance.leave_status_enum AS ENUM ('pending', 'approved', 'rejected', 'cancelled');
CREATE TYPE attendance.leave_type_enum AS ENUM ('sick', 'personal', 'vacation', 'emergency', 'medical', 'family');

CREATE TABLE attendance.leave_requests (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    requester_id UUID NOT NULL
        REFERENCES auth.users(id) ON DELETE CASCADE,   -- student or teacher
    target_type  VARCHAR(20) NOT NULL
        CHECK (target_type IN ('student','teacher')),
    target_id    UUID NOT NULL,                        -- FK depends on target_type (handled in app)

    leave_start  DATE NOT NULL,
    leave_end    DATE NOT NULL,
    leave_type   attendance.leave_type_enum NOT NULL,
    reason       TEXT,

    status       attendance.leave_status_enum NOT NULL DEFAULT 'pending',
    reviewed_by  UUID REFERENCES auth.users(id),
    reviewed_at  TIMESTAMPTZ,

    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ,
    deleted_at TIMESTAMPTZ,

    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id),
    deleted_by UUID REFERENCES auth.users(id)
);

-- Indexes
CREATE INDEX idx_leave_requests_requester   ON attendance.leave_requests(requester_id);
CREATE INDEX idx_leave_requests_status      ON attendance.leave_requests(status);
CREATE INDEX idx_leave_requests_reviewed_by ON attendance.leave_requests(reviewed_by);
CREATE INDEX idx_leave_requests_created_by  ON attendance.leave_requests(created_by);
CREATE INDEX idx_leave_requests_updated_by  ON attendance.leave_requests(updated_by);
CREATE INDEX idx_leave_requests_deleted_by  ON attendance.leave_requests(deleted_by);
```

---

### üö© `absentee_flags`

```sql
CREATE TABLE attendance.absentee_flags (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    student_id UUID NOT NULL
        REFERENCES student.students(id) ON DELETE CASCADE,
    flagged_on DATE NOT NULL,

    flag_type  VARCHAR(50) NOT NULL,                 -- chronic_absence | pattern_alert ‚Ä¶
    description TEXT,

    resolved    BOOLEAN DEFAULT FALSE,
    resolved_at TIMESTAMPTZ,

    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ,
    deleted_at TIMESTAMPTZ,

    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id),
    deleted_by UUID REFERENCES auth.users(id),

    CONSTRAINT unique_flag_per_student_date_type
        UNIQUE (student_id, flagged_on, flag_type)
);

-- Indexes
CREATE INDEX idx_absentee_flags_student     ON attendance.absentee_flags(student_id);
CREATE INDEX idx_absentee_flags_flag_type   ON attendance.absentee_flags(flag_type);
CREATE INDEX idx_absentee_flags_resolved    ON attendance.absentee_flags(resolved);
CREATE INDEX idx_absentee_flags_created_by  ON attendance.absentee_flags(created_by);
CREATE INDEX idx_absentee_flags_updated_by  ON attendance.absentee_flags(updated_by);
CREATE INDEX idx_absentee_flags_deleted_by  ON attendance.absentee_flags(deleted_by);
```

---

## üìå Design Notes & Rationale

- **Race-proof inserts** ‚Äî enforced by `UNIQUE (student_id, attendance_date)` **and** the explicit  
    `INSERT ‚Ä¶ ON CONFLICT ‚Ä¶` pattern shown above.
    
- Strict foreign keys keep attendance tightly linked to students, classes & sections.
    
- Enumerated `status` keeps downstream analytics tidy.
    
- `leave_requests` use a lightweight polymorphic target (`target_type` + `target_id`) to avoid cross-schema FK chaos.
    
- `absentee_flags` enable early-warning dashboards for chronic issues.
    
- Full auditing (`created_at / by`, `updated_at / by`, `deleted_at / by`) + soft-deletes across every table.
    
- Purpose-built indexes power daily reports, parent portals, and BI queries.
    

---
