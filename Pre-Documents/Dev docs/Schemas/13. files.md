
### 🗂️ Tables Overview:

|Table Name|Purpose|
|---|---|
|`file_uploads`|Stores metadata of uploaded files|
|`file_links`|Links files to other domain entities flexibly|

---

## 📄 Schema Definitions (PostgreSQL + SQL DDL)

---

### 🔧 **ENUMs**

```sql
-- File upload status
CREATE TYPE file_status AS ENUM ('active', 'archived', 'deleted');
```

---

### 📁 `file_uploads`

```sql
CREATE TABLE files.file_uploads (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    uploader_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE SET NULL,
    filename VARCHAR(255) NOT NULL,
    mime_type VARCHAR(100),
    size_bytes BIGINT NOT NULL,
    storage_provider VARCHAR(50) NOT NULL,   -- e.g., 'aws_s3', 'local_fs'
    storage_key TEXT NOT NULL,               -- bucket key / filepath

    status file_status DEFAULT 'active',     -- active, archived, deleted
    checksum VARCHAR(128),

    -- OPTIONAL back-reference to a *single* parent entity
    linked_table VARCHAR(100),
    linked_id    UUID,

    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ,
    deleted_at TIMESTAMPTZ,

    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    updated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    deleted_by UUID REFERENCES auth.users(id) ON DELETE SET NULL
);

CREATE INDEX idx_file_uploads_uploader    ON files.file_uploads(uploader_id);
CREATE INDEX idx_file_uploads_status      ON files.file_uploads(status);
CREATE INDEX idx_file_uploads_mime_type   ON files.file_uploads(mime_type);
CREATE INDEX idx_file_uploads_linked      ON files.file_uploads(linked_table, linked_id);
```

---

### 🔗 `file_links`

```sql
CREATE TABLE files.file_links (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    file_id UUID NOT NULL REFERENCES files.file_uploads(id) ON DELETE CASCADE,

    linked_table VARCHAR(100) NOT NULL,   -- target table, e.g. 'assignments'
    linked_id    UUID NOT NULL,           -- target record

    relation_type VARCHAR(50),            -- profile_picture, assignment_attachment …

    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ,
    deleted_at TIMESTAMPTZ,

    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    updated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    deleted_by UUID REFERENCES auth.users(id) ON DELETE SET NULL
);

CREATE INDEX idx_file_links_file_id       ON files.file_links(file_id);
CREATE INDEX idx_file_links_linked_entity ON files.file_links(linked_table, linked_id);
CREATE INDEX idx_file_links_relation_type ON files.file_links(relation_type);
```

> **🔒 Validation / Orphan-Guard Trigger**  
> Because `linked_table`/`linked_id` are polymorphic, a traditional foreign-key is impossible. Instead, create a **constraint trigger** that aborts an insert/update when the referenced row is missing:
> 
> ```sql
> CREATE OR REPLACE FUNCTION files.validate_file_link_f()
> RETURNS trigger LANGUAGE plpgsql AS
> $$
> BEGIN
>   PERFORM 1
>   FROM   pg_catalog.pg_class c
>   JOIN   pg_catalog.pg_namespace n ON n.oid = c.relnamespace
>   JOIN   pg_catalog.pg_tables    t ON t.tablename = c.relname
>   WHERE  c.relname = NEW.linked_table
>   LIMIT  1;
> 
>   IF NOT FOUND THEN
>     RAISE EXCEPTION 'linked_table % does not exist', NEW.linked_table;
>   END IF;
> 
>   -- dynamic SQL to verify the row exists
>   EXECUTE format('SELECT 1 FROM %I.%I WHERE id = $1 LIMIT 1',
>                  'public', NEW.linked_table)  -- adjust schema if needed
>   USING NEW.linked_id
>   INTO STRICT _dummy;
> 
>   RETURN NEW;
> END;
> $$;
> 
> CREATE CONSTRAINT TRIGGER trg_file_links_validate
> BEFORE INSERT OR UPDATE ON files.file_links
> FOR EACH ROW EXECUTE PROCEDURE files.validate_file_link_f();
> ```
> 
> _Alternate_: run a nightly cron:
> 
> ```sql
> DELETE FROM files.file_links fl
> WHERE NOT EXISTS (
>   SELECT 1
>   FROM   pg_catalog.pg_class c
>   WHERE  c.relname = fl.linked_table
> )
> OR NOT EXISTS (
>   SELECT 1
>   FROM   pg_catalog.pg_namespace n
>   JOIN   pg_catalog.pg_class c ON c.relnamespace = n.oid
>   WHERE  c.relname = fl.linked_table
>     AND  format('SELECT 1 FROM %I.%I WHERE id = %L',
>                 n.nspname, fl.linked_table, fl.linked_id)::TEXT IS NOT NULL
> );
> ```

---

## 📌 Indexing & Performance Notes

- Composite indexes on `(linked_table, linked_id)` speed look-ups and validation queries.
    
- `file_id → file_uploads.id` cascades deletions so dangling links vanish automatically.
    
- Bulk orphan cleanup is **idempotent** and inexpensive because of the supporting indexes.
    

---

## 🔐 Auditing & Soft-Delete Considerations

- Both tables carry `created_by / updated_by / deleted_by` for full traceability.
    
- Soft-delete (`deleted_at`) keeps historical records while hiding them from normal queries.
    
- Validation logic above prevents UI glitches caused by dangling or mistyped links.
    

---