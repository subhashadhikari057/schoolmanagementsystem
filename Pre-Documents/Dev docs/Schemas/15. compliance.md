# üìã Schema Documentation ‚Äî `Compliance Module`

> **Purpose**: GDPR/Privacy compliance tracking, user consent management, and data access auditing  
> **Schema**: `compliance`  
> **Dependencies**: `auth.users`  
> **Compliance**: GDPR, CCPA, Local Privacy Laws

---

### üóÇÔ∏è Tables Overview

| Table Name         | Purpose                                                          |
| ------------------ | ---------------------------------------------------------------- |
| `user_consents`    | Track user consent for data processing, marketing, cookies, etc. |
| `data_access_log`  | Audit trail for who accessed what personal data and when         |
| `privacy_requests` | Handle data subject requests (access, deletion, portability)     |
| `consent_versions` | Version control for consent forms and privacy policies           |

---

## üìÑ Schema Definitions (PostgreSQL DDL)

---

### üîê `user_consents`

```sql
-- Create ENUMs for compliance
CREATE TYPE compliance.consent_type_enum AS ENUM (
    'data_processing', 'marketing', 'cookies', 'analytics',
    'third_party_sharing', 'communication', 'research'
);

CREATE TYPE compliance.consent_method_enum AS ENUM (
    'explicit_checkbox', 'form_submission', 'email_confirmation',
    'verbal_consent', 'implied_consent', 'system_migration'
);

CREATE TABLE compliance.user_consents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    consent_type compliance.consent_type_enum NOT NULL,
    consent_given BOOLEAN NOT NULL,
    consent_method compliance.consent_method_enum NOT NULL,

    -- Tracking details
    consent_date TIMESTAMPTZ NOT NULL DEFAULT now(),
    expiry_date TIMESTAMPTZ,                    -- For time-limited consents
    withdrawal_date TIMESTAMPTZ,                -- When consent was withdrawn

    -- Audit information
    ip_address INET,
    user_agent TEXT,
    consent_version_id UUID REFERENCES compliance.consent_versions(id),

    -- Additional metadata
    consent_text TEXT,                          -- Exact text user consented to
    additional_metadata JSONB DEFAULT '{}',

    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ,
    deleted_at TIMESTAMPTZ,

    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id),
    deleted_by UUID REFERENCES auth.users(id),

    -- Ensure we track consent history properly
    CONSTRAINT valid_consent_dates
        CHECK (withdrawal_date IS NULL OR withdrawal_date >= consent_date),
    CONSTRAINT valid_expiry_dates
        CHECK (expiry_date IS NULL OR expiry_date >= consent_date)
);

-- Indexes for compliance queries
CREATE INDEX idx_user_consents_user_id ON compliance.user_consents(user_id);
CREATE INDEX idx_user_consents_type ON compliance.user_consents(consent_type);
CREATE INDEX idx_user_consents_date ON compliance.user_consents(consent_date);
CREATE INDEX idx_user_consents_active ON compliance.user_consents(user_id, consent_type)
    WHERE consent_given = true AND withdrawal_date IS NULL;
CREATE INDEX idx_user_consents_created_by ON compliance.user_consents(created_by);
CREATE INDEX idx_user_consents_updated_by ON compliance.user_consents(updated_by);
CREATE INDEX idx_user_consents_deleted_by ON compliance.user_consents(deleted_by);
```

---

### üìä `data_access_log`

```sql
-- Create ENUMs for data access tracking
CREATE TYPE compliance.access_type_enum AS ENUM (
    'view', 'edit', 'delete', 'export', 'print', 'download', 'share'
);

CREATE TYPE compliance.data_category_enum AS ENUM (
    'personal_info', 'academic_records', 'financial_data', 'health_records',
    'communication_logs', 'behavioral_data', 'location_data', 'device_data'
);

CREATE TABLE compliance.data_access_log (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    -- Who accessed what
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    accessed_by UUID NOT NULL REFERENCES auth.users(id) ON DELETE SET NULL,

    -- What was accessed
    data_category compliance.data_category_enum NOT NULL,
    access_type compliance.access_type_enum NOT NULL,
    resource_type VARCHAR(100) NOT NULL,        -- e.g., 'student_profile', 'payment_record'
    resource_id UUID,                           -- ID of the specific record

    -- Why it was accessed
    access_reason TEXT NOT NULL,                -- Required justification
    legal_basis VARCHAR(100),                   -- GDPR legal basis (consent, legitimate interest, etc.)

    -- When and how
    accessed_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    ip_address INET,
    user_agent TEXT,
    session_id UUID,

    -- Additional context
    fields_accessed JSONB,                      -- Specific fields that were accessed
    query_details JSONB,                        -- Query parameters, filters used
    additional_metadata JSONB DEFAULT '{}',

    created_at TIMESTAMPTZ DEFAULT now(),

    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id),
    deleted_by UUID REFERENCES auth.users(id),
    updated_at TIMESTAMPTZ,
    deleted_at TIMESTAMPTZ
);

-- Indexes for audit queries
CREATE INDEX idx_data_access_log_user_id ON compliance.data_access_log(user_id);
CREATE INDEX idx_data_access_log_accessed_by ON compliance.data_access_log(accessed_by);
CREATE INDEX idx_data_access_log_accessed_at ON compliance.data_access_log(accessed_at);
CREATE INDEX idx_data_access_log_data_category ON compliance.data_access_log(data_category);
CREATE INDEX idx_data_access_log_resource ON compliance.data_access_log(resource_type, resource_id);
CREATE INDEX idx_data_access_log_created_by ON compliance.data_access_log(created_by);
CREATE INDEX idx_data_access_log_updated_by ON compliance.data_access_log(updated_by);
CREATE INDEX idx_data_access_log_deleted_by ON compliance.data_access_log(deleted_by);
```

---

### üìù `privacy_requests`

```sql
-- Create ENUMs for privacy requests
CREATE TYPE compliance.request_type_enum AS ENUM (
    'data_access', 'data_deletion', 'data_portability', 'data_correction',
    'consent_withdrawal', 'processing_restriction', 'objection_to_processing'
);

CREATE TYPE compliance.request_status_enum AS ENUM (
    'submitted', 'under_review', 'in_progress', 'completed',
    'rejected', 'partially_fulfilled', 'cancelled'
);

CREATE TABLE compliance.privacy_requests (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    requester_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    request_type compliance.request_type_enum NOT NULL,
    status compliance.request_status_enum NOT NULL DEFAULT 'submitted',

    -- Request details
    request_description TEXT NOT NULL,
    specific_data_requested TEXT,               -- What specific data they want
    preferred_format VARCHAR(50),               -- JSON, CSV, PDF, etc.

    -- Processing details
    assigned_to UUID REFERENCES auth.users(id),
    priority_level INTEGER DEFAULT 1 CHECK (priority_level BETWEEN 1 AND 5),
    due_date TIMESTAMPTZ,                       -- Legal deadline (usually 30 days)

    -- Response details
    response_text TEXT,
    response_files JSONB,                       -- File URLs/IDs for data exports
    completion_date TIMESTAMPTZ,

    -- Audit trail
    submitted_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    last_updated_at TIMESTAMPTZ DEFAULT now(),

    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ,
    deleted_at TIMESTAMPTZ,

    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id),
    deleted_by UUID REFERENCES auth.users(id),

    -- Business rules
    CONSTRAINT valid_due_date
        CHECK (due_date IS NULL OR due_date >= submitted_at),
    CONSTRAINT valid_completion_date
        CHECK (completion_date IS NULL OR completion_date >= submitted_at)
);

-- Indexes for request management
CREATE INDEX idx_privacy_requests_requester ON compliance.privacy_requests(requester_id);
CREATE INDEX idx_privacy_requests_status ON compliance.privacy_requests(status);
CREATE INDEX idx_privacy_requests_assigned_to ON compliance.privacy_requests(assigned_to);
CREATE INDEX idx_privacy_requests_due_date ON compliance.privacy_requests(due_date);
CREATE INDEX idx_privacy_requests_type ON compliance.privacy_requests(request_type);
CREATE INDEX idx_privacy_requests_created_by ON compliance.privacy_requests(created_by);
CREATE INDEX idx_privacy_requests_updated_by ON compliance.privacy_requests(updated_by);
CREATE INDEX idx_privacy_requests_deleted_by ON compliance.privacy_requests(deleted_by);
```

---

### üìú `consent_versions`

```sql
CREATE TABLE compliance.consent_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    version_number VARCHAR(20) NOT NULL,        -- e.g., "1.0", "2.1", "2024.1"
    consent_type compliance.consent_type_enum NOT NULL,

    -- Version content
    consent_title VARCHAR(255) NOT NULL,
    consent_text TEXT NOT NULL,
    privacy_policy_url TEXT,

    -- Version lifecycle
    effective_from TIMESTAMPTZ NOT NULL,
    effective_until TIMESTAMPTZ,
    is_current BOOLEAN DEFAULT FALSE,

    -- Change tracking
    change_summary TEXT,                        -- What changed in this version
    legal_review_date TIMESTAMPTZ,
    reviewed_by UUID REFERENCES auth.users(id),

    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ,
    deleted_at TIMESTAMPTZ,

    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id),
    deleted_by UUID REFERENCES auth.users(id),

    -- Ensure version integrity
    CONSTRAINT unique_current_version_per_type
        EXCLUDE (consent_type WITH =) WHERE (is_current = true),
    CONSTRAINT valid_effective_dates
        CHECK (effective_until IS NULL OR effective_until > effective_from)
);

-- Indexes for version management
CREATE INDEX idx_consent_versions_type ON compliance.consent_versions(consent_type);
CREATE INDEX idx_consent_versions_current ON compliance.consent_versions(consent_type, is_current);
CREATE INDEX idx_consent_versions_effective ON compliance.consent_versions(effective_from, effective_until);
CREATE INDEX idx_consent_versions_created_by ON compliance.consent_versions(created_by);
CREATE INDEX idx_consent_versions_updated_by ON compliance.consent_versions(updated_by);
CREATE INDEX idx_consent_versions_deleted_by ON compliance.consent_versions(deleted_by);
```

---

## üîç **Compliance Query Examples**

### Check Active Consents for User

```sql
-- Get all active consents for a user
SELECT
    uc.consent_type,
    uc.consent_given,
    uc.consent_date,
    cv.version_number,
    cv.consent_title
FROM compliance.user_consents uc
LEFT JOIN compliance.consent_versions cv ON uc.consent_version_id = cv.id
WHERE uc.user_id = $1
  AND uc.withdrawal_date IS NULL
  AND (uc.expiry_date IS NULL OR uc.expiry_date > now())
ORDER BY uc.consent_date DESC;
```

### Audit Data Access for User

```sql
-- Get data access history for a user
SELECT
    dal.accessed_at,
    dal.accessed_by,
    u.full_name as accessed_by_name,
    dal.data_category,
    dal.access_type,
    dal.access_reason,
    dal.resource_type
FROM compliance.data_access_log dal
JOIN auth.users u ON dal.accessed_by = u.id
WHERE dal.user_id = $1
  AND dal.accessed_at >= $2  -- date range
ORDER BY dal.accessed_at DESC;
```

### Privacy Request Dashboard

```sql
-- Get privacy requests requiring attention
SELECT
    pr.id,
    pr.request_type,
    pr.status,
    pr.submitted_at,
    pr.due_date,
    u.full_name as requester_name,
    CASE
        WHEN pr.due_date < now() THEN 'OVERDUE'
        WHEN pr.due_date < now() + interval '3 days' THEN 'DUE_SOON'
        ELSE 'ON_TIME'
    END as urgency
FROM compliance.privacy_requests pr
JOIN auth.users u ON pr.requester_id = u.id
WHERE pr.status IN ('submitted', 'under_review', 'in_progress')
ORDER BY pr.due_date ASC;
```

---

## üö® **Compliance Triggers & Automation**

### Auto-expire Consents

```sql
-- Function to mark expired consents
CREATE OR REPLACE FUNCTION expire_old_consents()
RETURNS void AS $$
BEGIN
    UPDATE compliance.user_consents
    SET withdrawal_date = now(),
        updated_at = now(),
        updated_by = '00000000-0000-0000-0000-000000000000'::uuid -- system user
    WHERE expiry_date < now()
      AND withdrawal_date IS NULL;
END;
$$ LANGUAGE plpgsql;

-- Schedule to run daily
-- SELECT cron.schedule('expire-consents', '0 2 * * *', 'SELECT expire_old_consents();');
```

### Data Access Logging Trigger

```sql
-- Trigger to automatically log certain data access
CREATE OR REPLACE FUNCTION log_sensitive_data_access()
RETURNS TRIGGER AS $$
BEGIN
    -- Log access to sensitive tables
    INSERT INTO compliance.data_access_log (
        user_id, accessed_by, data_category, access_type,
        resource_type, resource_id, access_reason, legal_basis
    ) VALUES (
        COALESCE(NEW.user_id, OLD.user_id),
        current_setting('app.current_user_id')::uuid,
        'personal_info',
        CASE TG_OP
            WHEN 'INSERT' THEN 'edit'
            WHEN 'UPDATE' THEN 'edit'
            WHEN 'DELETE' THEN 'delete'
        END,
        TG_TABLE_NAME,
        COALESCE(NEW.id, OLD.id),
        'System operation',
        'legitimate_interest'
    );

    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

-- Apply to sensitive tables
-- CREATE TRIGGER log_student_access
--     AFTER INSERT OR UPDATE OR DELETE ON student.students
--     FOR EACH ROW EXECUTE FUNCTION log_sensitive_data_access();
```

---

## üìä **Compliance Reporting Views**

### Active Consent Summary

```sql
CREATE OR REPLACE VIEW compliance.active_consent_summary AS
SELECT
    consent_type,
    COUNT(*) as total_users,
    COUNT(*) FILTER (WHERE consent_given = true) as consented_users,
    COUNT(*) FILTER (WHERE consent_given = false) as declined_users,
    ROUND(
        COUNT(*) FILTER (WHERE consent_given = true) * 100.0 / COUNT(*), 2
    ) as consent_rate_percent
FROM compliance.user_consents uc
WHERE withdrawal_date IS NULL
  AND (expiry_date IS NULL OR expiry_date > now())
GROUP BY consent_type;
```

### Data Access Summary

```sql
CREATE OR REPLACE VIEW compliance.data_access_summary AS
SELECT
    DATE(accessed_at) as access_date,
    data_category,
    access_type,
    COUNT(*) as access_count,
    COUNT(DISTINCT user_id) as unique_users_accessed,
    COUNT(DISTINCT accessed_by) as unique_accessors
FROM compliance.data_access_log
WHERE accessed_at >= now() - interval '30 days'
GROUP BY DATE(accessed_at), data_category, access_type
ORDER BY access_date DESC, access_count DESC;
```

---

## üìù **Implementation Notes**

### GDPR Compliance Features

- **Consent Management**: Track explicit consent with version control
- **Data Access Logging**: Comprehensive audit trail for all personal data access
- **Right to be Forgotten**: Privacy request system for data deletion
- **Data Portability**: Export functionality for user data
- **Consent Withdrawal**: Easy withdrawal mechanism with audit trail

### Performance Considerations

- Indexes optimized for compliance queries
- Partitioning recommended for `data_access_log` (monthly partitions)
- Archive old consent records after legal retention period
- Consider read replicas for compliance reporting

### Security Notes

- All tables include audit columns (`created_by`, `updated_by`, `deleted_by`)
- Soft deletes preserve compliance history
- IP address and user agent tracking for consent authenticity
- Encrypted storage recommended for sensitive compliance data

---

**Schema Status**: ‚úÖ Ready for Implementation  
**Compliance Level**: GDPR, CCPA Compatible  
**Dependencies**: `auth.users` schema must exist  
**Migration Impact**: New schema, no existing data impact
