### üóÇÔ∏è Tables Overview:

| Table Name      | Purpose                                                         |
| --------------- | --------------------------------------------------------------- |
| `classes`       | Academic classes/grades (e.g., Grade 1, Grade 2)                |
| `sections`      | Class sections/groups (e.g., A, B, C)                           |
| `subjects`      | Subjects taught (e.g., Math, Science)                           |
| `assignments`   | Assignments linked to classes, sections, subjects, and teachers |
| `submissions`   | Student submissions for assignments                             |
| `grading_scale` | Standardized grading scale with structured fields               |

---

## üìÑ Schema Definitions (PostgreSQL + SQL DDL)

---

### üè´ `classes`

```sql
CREATE TABLE academics.classes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(50) NOT NULL, -- e.g., "Grade 1", "Grade 2"
    description TEXT,
    academic_year_id UUID NOT NULL REFERENCES configuration.academic_years(id) ON DELETE RESTRICT,

    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ,
    deleted_at TIMESTAMPTZ,

    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id),
    deleted_by UUID REFERENCES auth.users(id),

    CONSTRAINT unique_class_per_year UNIQUE (name, academic_year_id)
);

CREATE INDEX idx_classes_academic_year ON academics.classes(academic_year_id);
CREATE INDEX idx_classes_created_by ON academics.classes(created_by);
CREATE INDEX idx_classes_updated_by ON academics.classes(updated_by);
CREATE INDEX idx_classes_deleted_by ON academics.classes(deleted_by);
```

---

### üè∑Ô∏è `sections`

```sql
CREATE TABLE academics.sections (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    class_id UUID NOT NULL REFERENCES academics.classes(id) ON DELETE CASCADE,
    name VARCHAR(20) NOT NULL, -- e.g., "A", "B", "C"
    capacity INTEGER,
    additional_metadata JSONB DEFAULT '{}',

    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ,
    deleted_at TIMESTAMPTZ,

    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id),
    deleted_by UUID REFERENCES auth.users(id),

    CONSTRAINT unique_section_per_class UNIQUE (class_id, name)
);

CREATE INDEX idx_sections_class_id ON academics.sections(class_id);
CREATE INDEX idx_sections_created_by ON academics.sections(created_by);
CREATE INDEX idx_sections_updated_by ON academics.sections(updated_by);
CREATE INDEX idx_sections_deleted_by ON academics.sections(deleted_by);
```

---

### üìö `subjects`

```sql
CREATE TABLE academics.subjects (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) NOT NULL,
    code VARCHAR(20) UNIQUE,
    description TEXT,
    academic_year_id UUID NOT NULL REFERENCES configuration.academic_years(id) ON DELETE RESTRICT,
    additional_metadata JSONB DEFAULT '{}',

    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ,
    deleted_at TIMESTAMPTZ,

    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id),
    deleted_by UUID REFERENCES auth.users(id),

    CONSTRAINT unique_subject_per_year UNIQUE (name, academic_year_id)
);

CREATE INDEX idx_subjects_academic_year ON academics.subjects(academic_year_id);
CREATE INDEX idx_subjects_code ON academics.subjects(code);
CREATE INDEX idx_subjects_created_by ON academics.subjects(created_by);
CREATE INDEX idx_subjects_updated_by ON academics.subjects(updated_by);
CREATE INDEX idx_subjects_deleted_by ON academics.subjects(deleted_by);
```

---

### üìÑ `assignments`

```sql
CREATE TABLE academics.assignments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    title VARCHAR(255) NOT NULL,
    description TEXT,
    class_id UUID NOT NULL REFERENCES academics.classes(id) ON DELETE CASCADE,
    section_id UUID NOT NULL REFERENCES academics.sections(id) ON DELETE CASCADE,
    subject_id UUID NOT NULL REFERENCES academics.subjects(id) ON DELETE CASCADE,
    teacher_id UUID NOT NULL REFERENCES teacher.teachers(id) ON DELETE SET NULL,
    due_date TIMESTAMPTZ,
    additional_metadata JSONB DEFAULT '{}',

    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ,
    deleted_at TIMESTAMPTZ,

    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id),
    deleted_by UUID REFERENCES auth.users(id)
);

CREATE INDEX idx_assignments_class_section ON academics.assignments(class_id, section_id);
CREATE INDEX idx_assignments_subject ON academics.assignments(subject_id);
CREATE INDEX idx_assignments_teacher ON academics.assignments(teacher_id);
CREATE INDEX idx_assignments_due_date ON academics.assignments(due_date);
CREATE INDEX idx_assignments_created_by ON academics.assignments(created_by);
CREATE INDEX idx_assignments_updated_by ON academics.assignments(updated_by);
CREATE INDEX idx_assignments_deleted_by ON academics.assignments(deleted_by);
```

---

### üì§ `submissions`

```sql
CREATE TABLE academics.submissions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    assignment_id UUID NOT NULL REFERENCES academics.assignments(id) ON DELETE CASCADE,
    student_id UUID NOT NULL REFERENCES student.students(id) ON DELETE CASCADE,
    submitted_at TIMESTAMPTZ DEFAULT now(),
    grade VARCHAR(10),
    feedback TEXT,
    file_links JSONB DEFAULT '[]'::jsonb, -- URLs or references to stored files

    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ,
    deleted_at TIMESTAMPTZ,

    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id),
    deleted_by UUID REFERENCES auth.users(id),

    CONSTRAINT unique_submission UNIQUE (assignment_id, student_id)
);

CREATE INDEX idx_submissions_assignment ON academics.submissions(assignment_id);
CREATE INDEX idx_submissions_student ON academics.submissions(student_id);
CREATE INDEX idx_submissions_grade ON academics.submissions(grade);
CREATE INDEX idx_submissions_created_by ON academics.submissions(created_by);
CREATE INDEX idx_submissions_updated_by ON academics.submissions(updated_by);
CREATE INDEX idx_submissions_deleted_by ON academics.submissions(deleted_by);
```

---

### üìè `grading_scale`

```sql
CREATE TABLE academics.grading_scale (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    academic_year_id UUID NOT NULL REFERENCES configuration.academic_years(id),
    grade VARCHAR(5) NOT NULL,       -- e.g., "A+", "B", "C"
    min_percentage NUMERIC(5,2) NOT NULL,  -- e.g., 85.00
    max_percentage NUMERIC(5,2) NOT NULL,  -- e.g., 100.00
    remarks TEXT,
    additional_metadata JSONB DEFAULT '{}',

    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ,
    deleted_at TIMESTAMPTZ,

    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id),
    deleted_by UUID REFERENCES auth.users(id)
);

CREATE INDEX idx_grading_scale_academic_year ON academics.grading_scale(academic_year_id);
CREATE INDEX idx_grading_scale_grade ON academics.grading_scale(grade);
CREATE INDEX idx_grading_scale_created_by ON academics.grading_scale(created_by);
CREATE INDEX idx_grading_scale_updated_by ON academics.grading_scale(updated_by);
CREATE INDEX idx_grading_scale_deleted_by ON academics.grading_scale(deleted_by);
```

---

## üìå Indexing & Auditing Best Practices

- Composite indexes for common query patterns, e.g., `class_id + section_id` in `assignments`.
- Unique constraints prevent duplicate or conflicting records, e.g., section names per class, one submission per assignment/student.
- JSONB fields remain only for flexible, non-critical metadata.
- Extracted `grading_scale` now supports direct filtering by grade boundaries without parsing JSON.
- Auditing and soft deletion fields (`created_by`, `updated_by`, `deleted_at`, etc.) included on all tables.
- Foreign key integrity maintained across all academic entities.

---
