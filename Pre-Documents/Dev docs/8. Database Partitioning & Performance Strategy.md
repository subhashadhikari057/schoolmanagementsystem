## ðŸ“‹ **Overview**

This document outlines the comprehensive partitioning strategy for tables that will experience high growth rates. The strategy focuses on time-based partitioning with automated partition management to ensure optimal performance as the system scales.

---

## ðŸŽ¯ **Partitioning Targets**

### High-Volume Tables Requiring Partitioning

| Table             | Schema          | Growth Rate | Partition Strategy | Retention Policy |
| ----------------- | --------------- | ----------- | ------------------ | ---------------- |
| `audit_logs`      | `platform`      | ~10K/day    | Monthly            | 7 years          |
| `activity_logs`   | `platform`      | ~50K/day    | Monthly            | 2 years          |
| `data_access_log` | `compliance`    | ~5K/day     | Monthly            | 7 years (GDPR)   |
| `user_sessions`   | `auth`          | ~1K/day     | Monthly            | 90 days          |
| `file_uploads`    | `files`         | ~500/day    | Quarterly          | 5 years          |
| `notifications`   | `communication` | ~20K/day    | Monthly            | 1 year           |

---

## ðŸ—ï¸ **Partitioned Table Definitions**

### 1. Platform Audit Logs

```sql
-- Create partitioned audit_logs table
CREATE TABLE platform.audit_logs (
    id UUID DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES auth.users(id),
    action VARCHAR(100) NOT NULL,
    resource_type VARCHAR(100) NOT NULL,
    resource_id UUID,
    previous_state JSONB,
    new_state JSONB,
    ip_address INET,
    user_agent TEXT,
    session_id UUID,
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL,

    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id),
    deleted_by UUID REFERENCES auth.users(id),
    updated_at TIMESTAMPTZ,
    deleted_at TIMESTAMPTZ,

    PRIMARY KEY (id, created_at)
) PARTITION BY RANGE (created_at);

-- Create indexes on the parent table
CREATE INDEX idx_audit_logs_user_id ON platform.audit_logs(user_id, created_at);
CREATE INDEX idx_audit_logs_resource ON platform.audit_logs(resource_type, resource_id, created_at);
CREATE INDEX idx_audit_logs_action ON platform.audit_logs(action, created_at);
CREATE INDEX idx_audit_logs_session ON platform.audit_logs(session_id, created_at);
```

### 2. Activity Logs

```sql
-- Create partitioned activity_logs table
CREATE TABLE platform.activity_logs (
    id UUID DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES auth.users(id),
    activity_type VARCHAR(100) NOT NULL,
    activity_description TEXT,
    metadata JSONB DEFAULT '{}',
    ip_address INET,
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL,

    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id),
    deleted_by UUID REFERENCES auth.users(id),
    updated_at TIMESTAMPTZ,
    deleted_at TIMESTAMPTZ,

    PRIMARY KEY (id, created_at)
) PARTITION BY RANGE (created_at);

-- Indexes for activity logs
CREATE INDEX idx_activity_logs_user_id ON platform.activity_logs(user_id, created_at);
CREATE INDEX idx_activity_logs_type ON platform.activity_logs(activity_type, created_at);
CREATE INDEX idx_activity_logs_created_at ON platform.activity_logs(created_at);
```

### 3. Compliance Data Access Log (Already Partitioned)

```sql
-- Update existing data_access_log to be partitioned
ALTER TABLE compliance.data_access_log
ADD CONSTRAINT pk_data_access_log PRIMARY KEY (id, accessed_at);

-- Convert to partitioned table (requires recreation)
CREATE TABLE compliance.data_access_log_new (
    LIKE compliance.data_access_log INCLUDING ALL
) PARTITION BY RANGE (accessed_at);

-- Copy data and swap tables (done during maintenance window)
-- INSERT INTO compliance.data_access_log_new SELECT * FROM compliance.data_access_log;
-- DROP TABLE compliance.data_access_log;
-- ALTER TABLE compliance.data_access_log_new RENAME TO data_access_log;
```

---

## ðŸ¤– **Automated Partition Management**

### Partition Creation Function

```sql
-- Generic partition creation function
CREATE OR REPLACE FUNCTION create_monthly_partition(
    schema_name TEXT,
    table_name TEXT,
    partition_date DATE DEFAULT CURRENT_DATE
) RETURNS TEXT AS $$
DECLARE
    partition_name TEXT;
    start_date DATE;
    end_date DATE;
    sql_command TEXT;
BEGIN
    -- Calculate partition boundaries
    start_date := date_trunc('month', partition_date);
    end_date := start_date + INTERVAL '1 month';

    -- Generate partition name
    partition_name := table_name || '_' || to_char(start_date, 'YYYY_MM');

    -- Check if partition already exists
    IF EXISTS (
        SELECT 1 FROM information_schema.tables
        WHERE table_schema = schema_name
        AND table_name = partition_name
    ) THEN
        RETURN 'Partition ' || partition_name || ' already exists';
    END IF;

    -- Create partition
    sql_command := format(
        'CREATE TABLE %I.%I PARTITION OF %I.%I
         FOR VALUES FROM (%L) TO (%L)',
        schema_name, partition_name, schema_name, table_name,
        start_date, end_date
    );

    EXECUTE sql_command;

    -- Create partition-specific indexes
    EXECUTE format(
        'CREATE INDEX idx_%s_created_at ON %I.%I (created_at)',
        partition_name, schema_name, partition_name
    );

    RETURN 'Created partition: ' || partition_name;
END;
$$ LANGUAGE plpgsql;
```

### Batch Partition Creation

```sql
-- Create partitions for the next 12 months
CREATE OR REPLACE FUNCTION create_future_partitions(
    months_ahead INTEGER DEFAULT 12
) RETURNS TABLE(result TEXT) AS $$
DECLARE
    target_date DATE;
    i INTEGER;
    partition_result TEXT;
BEGIN
    FOR i IN 0..months_ahead LOOP
        target_date := CURRENT_DATE + (i || ' months')::INTERVAL;

        -- Create partitions for all partitioned tables
        SELECT create_monthly_partition('platform', 'audit_logs', target_date) INTO partition_result;
        RETURN NEXT;

        SELECT create_monthly_partition('platform', 'activity_logs', target_date) INTO partition_result;
        RETURN NEXT;

        SELECT create_monthly_partition('compliance', 'data_access_log', target_date) INTO partition_result;
        RETURN NEXT;

        SELECT create_monthly_partition('auth', 'user_sessions', target_date) INTO partition_result;
        RETURN NEXT;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- Execute to create initial partitions
SELECT * FROM create_future_partitions(12);
```

### Automated Partition Cleanup

```sql
-- Function to drop old partitions based on retention policy
CREATE OR REPLACE FUNCTION cleanup_old_partitions() RETURNS TABLE(result TEXT) AS $$
DECLARE
    partition_record RECORD;
    retention_policies JSONB;
    retention_months INTEGER;
    cutoff_date DATE;
    sql_command TEXT;
BEGIN
    -- Define retention policies (in months)
    retention_policies := '{
        "audit_logs": 84,
        "activity_logs": 24,
        "data_access_log": 84,
        "user_sessions": 3,
        "file_uploads": 60,
        "notifications": 12
    }'::JSONB;

    -- Find partitions to drop
    FOR partition_record IN
        SELECT
            schemaname,
            tablename,
            substring(tablename from '([^_]+_[^_]+)_\d{4}_\d{2}$') as base_table,
            substring(tablename from '\d{4}_\d{2}$') as partition_suffix
        FROM pg_tables
        WHERE tablename ~ '_\d{4}_\d{2}$'
        AND schemaname IN ('platform', 'compliance', 'auth', 'files', 'communication')
    LOOP
        -- Get retention policy for this table
        retention_months := (retention_policies->>partition_record.base_table)::INTEGER;

        IF retention_months IS NOT NULL THEN
            -- Calculate cutoff date
            cutoff_date := CURRENT_DATE - (retention_months || ' months')::INTERVAL;

            -- Check if partition is older than retention policy
            IF to_date(partition_record.partition_suffix, 'YYYY_MM') < cutoff_date THEN
                sql_command := format('DROP TABLE %I.%I',
                    partition_record.schemaname,
                    partition_record.tablename
                );

                EXECUTE sql_command;
                result := 'Dropped partition: ' || partition_record.tablename;
                RETURN NEXT;
            END IF;
        END IF;
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```

---

## ðŸ“… **Automated Scheduling**

### Cron Job Setup (using pg_cron extension)

```sql
-- Enable pg_cron extension
CREATE EXTENSION IF NOT EXISTS pg_cron;

-- Schedule monthly partition creation (1st of each month at 2 AM)
SELECT cron.schedule(
    'create-monthly-partitions',
    '0 2 1 * *',
    'SELECT create_future_partitions(3);'
);

-- Schedule quarterly partition cleanup (1st of each quarter at 3 AM)
SELECT cron.schedule(
    'cleanup-old-partitions',
    '0 3 1 */3 *',
    'SELECT cleanup_old_partitions();'
);

-- Schedule daily partition health check (every day at 1 AM)
SELECT cron.schedule(
    'partition-health-check',
    '0 1 * * *',
    'SELECT check_partition_health();'
);
```

### Alternative: Application-Level Scheduling

```javascript
// Node.js cron job for partition management
const cron = require("node-cron");
const { Pool } = require("pg");

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
});

// Create partitions monthly
cron.schedule("0 2 1 * *", async () => {
  try {
    const result = await pool.query("SELECT create_future_partitions(3)");
    console.log("Monthly partitions created:", result.rows);
  } catch (error) {
    console.error("Error creating partitions:", error);
  }
});

// Cleanup old partitions quarterly
cron.schedule("0 3 1 */3 *", async () => {
  try {
    const result = await pool.query("SELECT cleanup_old_partitions()");
    console.log("Old partitions cleaned:", result.rows);
  } catch (error) {
    console.error("Error cleaning partitions:", error);
  }
});
```

---

## ðŸ“Š **Monitoring & Health Checks**

### Partition Health Check Function

```sql
CREATE OR REPLACE FUNCTION check_partition_health()
RETURNS TABLE(
    schema_name TEXT,
    table_name TEXT,
    partition_count INTEGER,
    total_size TEXT,
    largest_partition TEXT,
    largest_size TEXT,
    status TEXT
) AS $$
BEGIN
    RETURN QUERY
    WITH partition_stats AS (
        SELECT
            pt.schemaname,
            pt.tablename,
            COUNT(*) as partition_count,
            pg_size_pretty(SUM(pg_total_relation_size(pt.schemaname||'.'||pt.tablename))) as total_size,
            (array_agg(pt.tablename ORDER BY pg_total_relation_size(pt.schemaname||'.'||pt.tablename) DESC))[1] as largest_partition,
            pg_size_pretty(MAX(pg_total_relation_size(pt.schemaname||'.'||pt.tablename))) as largest_size
        FROM pg_tables pt
        WHERE pt.tablename ~ '_\d{4}_\d{2}$'
        GROUP BY pt.schemaname, substring(pt.tablename from '([^_]+_[^_]+)_\d{4}_\d{2}$')
    )
    SELECT
        ps.schemaname,
        substring(ps.tablename from '([^_]+_[^_]+)_\d{4}_\d{2}$') as base_table,
        ps.partition_count,
        ps.total_size,
        ps.largest_partition,
        ps.largest_size,
        CASE
            WHEN ps.partition_count < 2 THEN 'WARNING: Too few partitions'
            WHEN ps.partition_count > 100 THEN 'WARNING: Too many partitions'
            ELSE 'OK'
        END as status
    FROM partition_stats ps;
END;
$$ LANGUAGE plpgsql;
```

### Performance Monitoring Queries

```sql
-- Monitor partition performance
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as size,
    (SELECT count(*) FROM information_schema.tables WHERE table_name = tablename) as row_count_estimate
FROM pg_tables
WHERE tablename ~ '_\d{4}_\d{2}$'
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC
LIMIT 20;

-- Check for missing partitions (gaps in monthly sequence)
WITH expected_partitions AS (
    SELECT
        generate_series(
            date_trunc('month', CURRENT_DATE - INTERVAL '12 months'),
            date_trunc('month', CURRENT_DATE + INTERVAL '3 months'),
            INTERVAL '1 month'
        )::DATE as expected_date
),
actual_partitions AS (
    SELECT
        to_date(substring(tablename from '\d{4}_\d{2}$'), 'YYYY_MM') as partition_date,
        tablename
    FROM pg_tables
    WHERE tablename LIKE 'audit_logs_%'
    AND tablename ~ '_\d{4}_\d{2}$'
)
SELECT
    ep.expected_date,
    CASE WHEN ap.tablename IS NULL THEN 'MISSING' ELSE 'EXISTS' END as status
FROM expected_partitions ep
LEFT JOIN actual_partitions ap ON ep.expected_date = ap.partition_date
ORDER BY ep.expected_date;
```

---

## ðŸš€ **Migration Scripts**

### Prisma Migration Script

```javascript
// scripts/createPartitions.js
const { PrismaClient } = require("@prisma/client");

const prisma = new PrismaClient();

async function createInitialPartitions() {
  console.log("Creating initial partitions...");

  try {
    // Create partitions for the next 12 months
    const result = await prisma.$queryRaw`
      SELECT create_future_partitions(12);
    `;

    console.log("Partitions created:", result);

    // Verify partition creation
    const healthCheck = await prisma.$queryRaw`
      SELECT * FROM check_partition_health();
    `;

    console.log("Partition health check:", healthCheck);
  } catch (error) {
    console.error("Error creating partitions:", error);
    throw error;
  } finally {
    await prisma.$disconnect();
  }
}

// Run if called directly
if (require.main === module) {
  createInitialPartitions()
    .then(() => {
      console.log("Partition setup completed successfully");
      process.exit(0);
    })
    .catch((error) => {
      console.error("Partition setup failed:", error);
      process.exit(1);
    });
}

module.exports = { createInitialPartitions };
```

### Docker Compose Integration

```yaml
# docker-compose.yml addition for partition management
services:
  partition-manager:
    image: node:18-alpine
    depends_on:
      - postgres
    environment:
      - DATABASE_URL=${DATABASE_URL}
    volumes:
      - ./scripts:/app/scripts
    working_dir: /app
    command: >
      sh -c "
        npm install pg node-cron &&
        node scripts/partitionManager.js
      "
    restart: unless-stopped
```

---

## ðŸ“ˆ **Performance Benefits**

### Expected Performance Improvements

| Operation                  | Before Partitioning | After Partitioning | Improvement                 |
| -------------------------- | ------------------- | ------------------ | --------------------------- |
| Recent audit log queries   | 2-5 seconds         | 50-200ms           | 90%+ faster                 |
| Monthly compliance reports | 10-30 seconds       | 1-3 seconds        | 80%+ faster                 |
| Partition pruning          | N/A                 | Automatic          | Eliminates irrelevant scans |
| Maintenance operations     | Hours               | Minutes            | 95%+ faster                 |
| Index rebuilds             | Full table          | Per partition      | Parallelizable              |

### Query Optimization Examples

```sql
-- Before: Scans entire table
SELECT * FROM audit_logs
WHERE created_at >= '2024-01-01'
AND created_at < '2024-02-01';

-- After: Only scans January 2024 partition
-- PostgreSQL automatically prunes other partitions
SELECT * FROM audit_logs
WHERE created_at >= '2024-01-01'
AND created_at < '2024-02-01';

-- Parallel maintenance across partitions
REINDEX INDEX CONCURRENTLY idx_audit_logs_user_id_2024_01;
REINDEX INDEX CONCURRENTLY idx_audit_logs_user_id_2024_02;
-- ... can run simultaneously
```

---

## ðŸ”§ **Implementation Checklist**

### Pre-Implementation

- [ ] Backup existing data
- [ ] Test partition creation on staging
- [ ] Verify application compatibility
- [ ] Plan maintenance window

### Implementation Phase

- [ ] Create partitioned table structures
- [ ] Migrate existing data to partitions
- [ ] Update application connection strings
- [ ] Deploy partition management functions
- [ ] Set up automated scheduling

### Post-Implementation

- [ ] Monitor partition performance
- [ ] Verify automated partition creation
- [ ] Test partition pruning
- [ ] Document operational procedures
- [ ] Train team on partition management

---

## ðŸš¨ **Troubleshooting Guide**

### Common Issues and Solutions

| Issue                     | Symptoms                            | Solution                                           |
| ------------------------- | ----------------------------------- | -------------------------------------------------- |
| Missing partitions        | Query errors, constraint violations | Run `create_future_partitions()`                   |
| Oversized partitions      | Slow queries, high memory usage     | Consider daily partitioning for high-volume tables |
| Failed partition creation | Cron job errors                     | Check permissions and disk space                   |
| Constraint violations     | INSERT failures                     | Ensure partition exists for target date            |
| Slow partition pruning    | Queries scan multiple partitions    | Add explicit date filters to queries               |

### Emergency Procedures

```sql
-- Emergency partition creation
SELECT create_monthly_partition('platform', 'audit_logs', CURRENT_DATE);

-- Check partition constraint exclusion
EXPLAIN (BUFFERS, ANALYZE)
SELECT * FROM audit_logs
WHERE created_at >= CURRENT_DATE - INTERVAL '1 day';

-- Manual partition drop (emergency cleanup)
DROP TABLE IF EXISTS platform.audit_logs_2023_01;
```

---
